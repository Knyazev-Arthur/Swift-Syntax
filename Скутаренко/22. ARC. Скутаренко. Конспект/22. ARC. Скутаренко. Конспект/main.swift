/// ЧАСТЬ 1 - про сильные и слабые ссылки.

/// ARC работает с reference type
var playground = true

/*
class Student {
	
	weak var teacher: Teacher /// weak говорит нам, что на объект устанавливается слабая ссылка
	
	deinit {
		print("goodbye student")
	}
}

class Teacher {
	
	var student: Student?
	
	deinit {
		print("goodbye teacher")
	}
}


/// Пока объект в зоне видимости кол-во ссылок на него - 1
/// После выхода объекта из зоны видимости ссылок на него - 0
/// Если на объект отсутствуют ссылки он будет уничтожен.
/// Как будут уничтожены объекты student, teacher, если на них не будет установлена сильная (strong) ссылка вне тела условия

/// Распространенная ситуация, когда у объектов есть ссылка друг на друга - сильные перекрестные ссылки, когда объектам необходимо обмениваться информацией друг с другом

/// При объявлении свойства создается сильная ссылка по умолчанию
/// Если свойство ссылается на другой объект, то на этот объектп появляется еще одная сильная ссылка, которая может быть уничтожена только вместе с объектом
/// Объект живет до тех пор, пока на него есть хотя бы одная сильная ссылка
/// weak всегда используется со свойствами типа optional, которое всегда должно быть инициализировано перменной, поскольку может быть изменено на nil.
/// С неопциональными типами используем unowned (бесхозная ссылка, не принадлежащая объекту)


if playground {
	
	let teacher = Teacher() /// 1 ссылка на teacher
	
	if playground {
		let student = Student() /// 1 ссылка на student
		teacher.student = student /// 2 ссылка на student, которую объявил экземпляр класса Teacher
		student.teacher = teacher /// 2 ссылка на teacher которую объявил экземпляр класса Student, но которая не увеличивает счетчик ссылок на объект поскольку является слабой
	}
	print("exit playground")
}
print("end")


/// даже когда объекты выходят из зоны видимости, но них будут указываться сильные ссылки друг друга, это не позволит им удалиться.
/// ситуация, когда объекты вышли из зоны видимости и на них нельзя ссылаться, но они не удалена, а значит занимают память - называется утечкой памяти

/// Подитог - если у нас есть одни главный объект и один зависимый, и они должны общаться друг с другом, то зависимого надо делать слабой ссылкой(weak)


class Student {
	unowned let teacher: Teacher
	
	init(teacher: Teacher) {
		self.teacher = teacher
	}
	
	deinit {
		print("goodbye student")
	}
}

class Teacher {
	var student: Student!
	
	init() {
		student = Student(teacher: self) /// отсутствует доступ к студенту поскольку не прошла 1 фаза инициализации. Чтобы это обойти модно присвоить переменной student тип optional
	}
	
	deinit {
		print("goodbye teacher")
	}
}


if playground {
	
	var teacher = Teacher()
	
	if playground {
		let student = Student(teacher: teacher)
		teacher.student = student
	}
	print("exit playground")
}
print("end")
*/



/// ЧАСТЬ 2 - про замыкания
var x = 10
var y = 20

class Human {
	var name = "a"
}

var h = Human()



var closure1 : () -> () = { /// клоужер захватывает value type, как reference type
	[x,y] in /// лист захвата позволяет клоужеру закрепить значенияобъявленные на момент захвата
	print("\(x) \(y)")
}

closure1()



var closure2: (Int) -> Int = {[x,y,h] (a: Int) -> Int in /// добавляем лист захвата в
	print("\(x) \(y) \(h.name)")
	return a
}

x = 30
y = 40

h = Human()
h.name = "b"

var a = closure2(1)



class Student {
	unowned let teacher: Teacher
	
	init(teacher: Teacher) {
		self.teacher = teacher
	}
	
	deinit {
		print("goodbye student")
	}
}

class Teacher {
	var student: Student!
	
	var test: (() -> ())?
	
	lazy var test2: (Bool) -> () = {
		[unowned self] (a: Bool) in
		print(self.student)
	}
	
	init() {
		student = Student(teacher: self) /// отсутствует доступ к студенту поскольку не прошла 1 фаза инициализации. Чтобы это обойти модно присвоить переменной student тип optional
	}
	
	deinit {
		print("goodbye teacher")
	}
}


var closure: (() -> ())? /// опциональное замыкание, оно еще не объявлено


if playground {
	
	var teacher = Teacher()
	
	teacher.test2(true)
	
//	teacher.test = {
//		[unowned teacher] in
//		print(teacher)
//	}
	
//	var student = teacher.student
//	closure = {
//		[unowned student] in /// лист захвата с бесхозной ссылкой
//		print(student) /// т.к. замыкание захватившее значение teacher сильной ссылкой объявлено вне зоны видимости, то объекты не удалятся
//	}
	
	print("exit playground")
}



/// Если есть 2 объекта, ссылающиеся друг на друга и один из них главный, который держать подчиненного, то он должен держать его сильной ссылкой, а подчиненный главного слабой
/// Клоужеры всегда захватывают все что мы им передаем сильными ссылками. Поэтому если мы работаем с value type, которые передаем клоужеру и не хотим, чтобы они менялись, создаем лист захвата.
/// Если мы не хотим, чтобы из-за захваченного клоужером объекта, он оставался жить даже после его выхода из зоны видимости, стоит объявить в листе захвата слабую ссылку на объект



/// 1) если есть 2 объекта, которые друг на друга ссылаются и один из них главный, а другой подчиненный (мастер и слейв) - мастер должен держать подчиненного сильной ссылкой, а подчиненный главновного должен держать слабой ссылкой (weak \ unowned), weak - для опциональных переменных, unowned - для не опциональных переменных/констант

///если объект, на который были слабые ссылки - умрет (релизнется). То при обращении к нему будет ошибка. В одном случае там будет nil, а в другом полный garbage (мусор).
///
///
///// 2) клоужеры захватывают всё что в них передаем (весь контекст который мы в них передаем)
// если мы используем value type, и мы не хотим что бы он менялся после того как мы объявляем первый раз клоужер - помещаем в кэпчур лист
// если мы работаем с referance type (объекты классов например), то помним что они будут в клоужер захватываться сильной ссылкой
// чтобы избежать, что объект будет жить пока живёт клоужер (что может тоже создать циклические strong referance друг на друга) - то надо добавлять и в кэпчур лист и добавлять, что они unowned (или weak)

// тоже самое, если клоужер - это проперти (лейзи и не лейзи) и мы работаем с self, то тоже работем с кепчур лист и добавляем unowned

// PS что не сказал сразу, если объекты добавить в массив, дикшинари, коллекцию , то массив будет их держать сильными ссылками
